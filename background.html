<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Premium Mesh Blob Background</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            background: #ffffff;
            /* ✅ white background */
            overflow: hidden;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        #bg {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="bg"></div>

    <script type="module">
        import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

        const container = document.getElementById("bg");

        // Scene
        const scene = new THREE.Scene();

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0xffffff, 1); // ✅ pure white
        container.appendChild(renderer.domElement);

        // Geometry: organic base (NOT cube)
        // Higher detail -> smoother deformation, but keep reasonable for perf
        const geometry = new THREE.IcosahedronGeometry(6.2, 6);

        // Convert to Points look (mesh-like / airy)
        // Using Points + shader-driven color = soft “wire/mesh” vibe without heavy line rendering
        const uniforms = {
            uTime: { value: 0 },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uMouseSmoothed: { value: new THREE.Vector2(0, 0) },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uPointSize: { value: 1.9 },
            uOpacity: { value: 0.72 },
        };

        const vertexShader = /* glsl */`
      uniform float uTime;
      uniform vec2 uMouseSmoothed;
      uniform float uPointSize;
      varying float vNoise;
      varying vec3 vPos;

      // ---- Simplex noise (3D) ----
      vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
      vec4 mod289(vec4 x){ return x - floor(x*(1.0/289.0))*289.0; }
      vec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }

      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0);
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 1.0/7.0;
        vec3  ns = n_*D.wyz - D.xzx;

        vec4 j = p - 49.0*floor(p*ns.z*ns.z);

        vec4 x_ = floor(j*ns.z);
        vec4 y_ = floor(j - 7.0*x_);

        vec4 x = x_*ns.x + ns.yyyy;
        vec4 y = y_*ns.x + ns.yyyy;

        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m*m;

        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        vPos = position;

        // Slow, calm organic motion
        float t = uTime * 0.18;

        // Base noise displacement
        float n1 = snoise(vec3(position * 0.23 + vec3(t, t*0.8, t*0.6)));
        float n2 = snoise(vec3(position * 0.38 + vec3(-t*0.7, t*0.5, t)));
        float noise = 0.65*n1 + 0.35*n2;
        vNoise = noise;

        vec3 pos = position;

        // Keep it soft and premium (small displacement)
        float displacement = noise * 0.85;
        pos += normalize(position) * displacement;

        // Mouse proximity effect (gentle)
        // Map mouse (-1..1) to an influence region in object XY
        vec2 m = uMouseSmoothed * 6.5; // object-space-ish scale
        float d = distance(pos.xy, m);
        float influence = smoothstep(5.0, 0.0, d); // closer = stronger
        pos += normalize(position) * (influence * 1.05);

        // Subtle “breathing”
        float breathe = 0.10 * sin(uTime * 0.55);
        pos += normalize(position) * breathe;

        // Model-view projection
        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPos;

        // Point size scales with depth
        gl_PointSize = uPointSize * (24.0 / -mvPos.z);
      }
    `;

        const fragmentShader = /* glsl */`
      uniform float uOpacity;
      varying float vNoise;
      varying vec3 vPos;

      float sat(float x){ return clamp(x, 0.0, 1.0); }

      void main() {
        // Soft circular point
        vec2 uv = gl_PointCoord - vec2(0.5);
        float r = length(uv);
        float alpha = smoothstep(0.52, 0.10, r);

        // Color blending (Magenta / Cyan / Amber)
        vec3 magenta = vec3(0.91, 0.23, 0.62);
        vec3 cyan    = vec3(0.30, 0.76, 0.95);
        vec3 amber   = vec3(0.98, 0.78, 0.30);

        // Use position + noise to smoothly mix (no harsh bands)
        float k1 = sat(0.5 + 0.5 * sin(vPos.x * 0.18 + vNoise * 1.6));
        float k2 = sat(0.5 + 0.5 * sin(vPos.y * 0.16 - vNoise * 1.2 + 1.2));
        float k3 = sat(0.5 + 0.5 * sin(vPos.z * 0.14 + vNoise * 1.0 + 2.4));

        // Normalize weights
        float sum = (k1 + k2 + k3) + 1e-6;
        vec3 col = (magenta*k1 + cyan*k2 + amber*k3) / sum;

        // Very subtle shading variation (premium, not noisy)
        float shade = 0.92 + 0.08 * (vNoise * 0.5 + 0.5);
        col *= shade;

        gl_FragColor = vec4(col, alpha * uOpacity);
      }
    `;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.NormalBlending
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // Smooth mouse (lerp)
        let targetMouse = new THREE.Vector2(0, 0);
        let smoothMouse = new THREE.Vector2(0, 0);

        window.addEventListener("mousemove", (e) => {
            const x = (e.clientX / window.innerWidth) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            targetMouse.set(x, y);
            uniforms.uMouse.value.copy(targetMouse);
        }, { passive: true });

        // Resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        // Animate
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsed = clock.getElapsedTime();
            uniforms.uTime.value = elapsed;

            // Lerp mouse for smooth interaction
            smoothMouse.lerp(targetMouse, 0.06);
            uniforms.uMouseSmoothed.value.copy(smoothMouse);

            // Subtle rotation (calm)
            points.rotation.y = elapsed * 0.10;
            points.rotation.x = Math.sin(elapsed * 0.12) * 0.08;

            // Gentle drift
            points.position.x = Math.sin(elapsed * 0.10) * 0.25;
            points.position.y = Math.cos(elapsed * 0.09) * 0.18;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>